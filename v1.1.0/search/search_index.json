{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>This specification sets out requirements for Application Programming Interfaces (APIs) in Dutch Healthcare. It has been developed as part of the Nictiz API strategy.</p>"},{"location":"#nictiz","title":"Nictiz","text":"<p>Nictiz is the Dutch competence centre for electronic exchange of health and care information. Nictiz develops and maintains standards for digital information management, ensuring that healthcare information can be recorded and exchanged in an unambiguous manner. To this end Nictiz maintains close cooperation with the international Standardization Organizations: IHE, HL7, SNOMED International, PCH Alliance, CEN/NEN.</p>"},{"location":"#contributions","title":"Contributions","text":"<p>Please contribute! We will gladly review any pull requests. Make sure to read the Contributing page first though.</p>"},{"location":"#license","title":"License","text":"<pre><code>Copyright 2023 Nictiz\n\nLicensed under the Creative Commons Attribution-ShareAlike 4.0\nInternational (CC BY-SA 4.0) License, (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    https://creativecommons.org/licenses/by-sa/4.0/\n</code></pre>"},{"location":"api-agreements/","title":"API agreements","text":""},{"location":"api-agreements/#ag001-api-service-levels-must-be-openly-and-freely-available","title":"AG001: API Service Levels MUST be openly and freely available","text":"<p>With the intention to protect API client developers, API users and API client deployers from unpredictable service level quality.</p> Applicable roles API server deployer Standardization levels OA, TSA, FSA Status Final Since version 1.0.0"},{"location":"api-agreements/#sub-requirements","title":"Sub-requirements","text":"<ul> <li>AG001.001: API Service Levels MUST be documented in the form of an agreement between API server deployer, API   client developer and/or API client deployer</li> <li>AG001.002: The API server deployer MAY require API client developers and/or API client deployers to sign a   Service Level Agreement before using the API</li> <li>AG001.003: Service Levels MAY be provided on a best-efforts basis</li> <li>AG001.004: If Service Levels are provided on a best-efforts basis, the SLA documentation MUST explicitly state   relevant terms such as no liability for costs or charges incurred in the event of unavailability of the API</li> <li>AG001.005: Service Levels MAY be provided in tiers, such as free tiers without developer support and paid   tiers that include developer support</li> <li>AG001.006: API Service Levels MUST be documented to the extent that API client developers and API client   deployers are fully informed about the duties and responsibilities of each party involved and about the remedies or   penalties for breaching these duties and </li> <li>AG001.007: The API Service Levels MUST at least include a description of the service(s) provided</li> <li>AG001.008: The API Service Levels MUST at least include availability requirements, such as days and times the   API is available and any restrictions for special days</li> <li>AG001.009: The API Service Levels MUST at least include details on planned outage and unplanned outage,   expressed as a maximum percentage of total availability times</li> <li>AG001.010: The API Service Levels MUST at least include response time expectations, such as a percentage of   calls that return within a given amount of time</li> <li>AG001.011: The API Service Levels MUST at least include details on technical support and support windows such   as developer support or other technical support</li> <li>AG001.012: The API Service Levels MUST describe any restrictions on using the API</li> <li>AG001.013: The API Service Levels MUST at least include usage restrictions, such as number of calls per time   unit or maximum call size and consequences for exceeding these restrictions</li> <li>AG001.014: The API Service Levels MUST at least include any terms and conditions regarding the use of the data   acquired via the API, including requirements and responsibilities for secure and lawful use of data returned by the   API such as retention and destruction policies</li> <li>AG001.015: The API Service Levels MUST at least include any restrictions on what persons or organizations are   allowed to access the API (API access restriction policies)</li> <li>AG001.016: If the API server deployer provides online test tooling, Service Levels for test tooling MUST be   described using the same metrics for availability, outage, usage restrictions, response times and technical support</li> <li>AG001.017: If the API server deployer provides offline test tooling, only details on technical support MUST be   provided for the offline test tool</li> <li>AG001.018: The API Service Level Agreement MUST detail the process and restrictions for changing the agreement   and/or service levels</li> </ul>"},{"location":"api-agreements/#ag002-api-access-restriction-policies-must-be-openly-and-freely-available","title":"AG002: API Access Restriction Policies MUST be openly and freely available","text":"<p>With the intention to prevent information blocking strategies based on arbitrary access to APIs.</p> Applicable roles API server deployer Standardization levels OA, TSA, FSA Status Final Since version 1.0.0"},{"location":"api-agreements/#sub-requirements_1","title":"Sub-requirements","text":"<ul> <li>AG002.001: Any restrictions on persons or organizations to access and/or use the API MUST be transparent and   documented</li> <li>AG002.002: The API server deployer MUST NOT restrict persons or organizations from using the API for reasons   other than the documented access restriction policies</li> <li>AG002.003: Access Restriction Policies MAY include an accreditation process and review of the API client   system, API client developer organization and/or API client deployer organization</li> <li>AG002.004: If an accreditation process is in place, details on how accreditation is achieved MUST be provided,   including criteria for exclusion</li> </ul>"},{"location":"api-agreements/#ag003-data-processing-policies-must-be-openly-and-freely-available","title":"AG003: Data Processing Policies MUST be openly and freely available","text":"<p>With the intention to protect API user, API client developer and API client deployer organizations from unwanted use of API usage data.</p> Applicable roles API server deployer Standardization levels OA, TSA, FSA Status Final Since version 1.0.0"},{"location":"api-agreements/#sub-requirements_2","title":"Sub-requirements","text":"<ul> <li>AG003.001: API server deployer Data Processing Policies MUST be documented</li> <li>AG003.002: API server deployer Data Processing Policies MUST include at least the details on how API usage   will be monitored and what data will be stored as part of the monitoring process, such as IP addresses of the API   deployer or API user<ul> <li>This requirement concerns monitoring data that is not personal data. Requirements for the processing of personal   data is the concern of the European General Data Protection Regulation (GDPR) and therefore is   not part of this specification.</li> </ul> </li> <li>AG003.003: API server deployers MAY document details on processing personal data</li> </ul>"},{"location":"api-agreements/#ag004-when-an-api-server-deployer-charges-api-client-developers-andor-api-client-deployers-for-using-the-api-in-a-production-environment-any-fees-must-be-predictable-and-openly-and-freely-available","title":"AG004: When an API server deployer charges API client developers and/or API client deployers for using the API in a production environment, any fees MUST be predictable and openly and freely available","text":"<p>With the intention to prevent information blocking strategies based on non-transparent pricing.</p> Applicable roles API server deployer Standardization levels OA, TSA, FSA Status Final Since version 1.0.0"},{"location":"api-agreements/#sub-requirements_3","title":"Sub-requirements","text":"<ul> <li>AG004.001: Fees MUST be predictable, meaning that the API client developer and the API client deployer have   enough pricing information to predict the cost of API usage for at least two years after signing the agreement</li> </ul>"},{"location":"api-design-rules/","title":"API design rules","text":"<p>Design rules focus on the technical implementation of the APIs.</p>"},{"location":"api-design-rules/#compliance-with-national-api-design-rules","title":"Compliance with national API design rules","text":"<p>The Dutch National API strategy by Geonovum contains design rules that were considered when writing this chapter. Unfortunately, these rules would exclude the use of FHIR, which is the most considered base for any RESTful transaction in healthcare. It also focuses on the use of RESTful interfaces, while SOAP is still used for APIs as well, especially with IHE-profiles, like XDS, XCA, etc.</p>"},{"location":"api-design-rules/#generic","title":"Generic","text":""},{"location":"api-design-rules/#dr001-interfaces-must-be-defined-in-english","title":"DR001: Interfaces MUST be defined in English","text":"<p>Healthcare APIs are used internationally, which is why a lot are already available in English. Conforming to this will help with uniformity and attract non-Dutch developers.</p> Applicable roles API specifier Standardization levels TSA, FSA Status Final Since version 1.0.0"},{"location":"api-design-rules/#dr002-developers-must-only-apply-standard-http-methods","title":"DR002: Developers MUST only apply standard HTTP methods","text":"<p>The HTTP specification (RFC 7231) and the later introduced PATCH method specification (RFC 5789) offer a set of standard methods, where every method is designed with explicit semantics. Adhering to the HTTP specification is crucial since HTTP clients and middleware applications rely on standardized characteristics. Therefore, resources must be retrieved or manipulated using standard HTTP methods.</p> Applicable roles API server developer Standardization levels TSA, FSA Status Final Since version 1.0.0 Dutch National API strategy API-03"},{"location":"api-design-rules/#sub-requirements","title":"Sub-requirements","text":"<ul> <li>DR002.001: HTTP GET method MUST be used to retrieve a resource representation for the given URI<ul> <li>Data is only retrieved and never modified.</li> </ul> </li> <li>DR002.002: HTTP POST method MUST be used to create a resource<ul> <li>The receiver generates a new URI.</li> </ul> </li> <li>DR002.003: HTTP PUT method MUST be used to create a resource with the given URI or replace (full update) a resource when the resource already exists</li> <li>DR002.004: HTTP PATCH method MUST be used to partially update an existing resource<ul> <li>The request only contains the resource modifications instead of the full resource representation.</li> </ul> </li> <li>DR002.005: HTTP DELETE method MUST be used to remove a resource with the given URI</li> </ul> Method Operation Description <code>GET</code> Read Retrieve a resource representation for the given URI. Data is only retrieved and never modified. <code>POST</code> Create Create a resource. The receiver generates a new URI. <code>PUT</code> Create/update Create a resource with the given URI or replace (full update) a resource when the resource already exists. <code>PATCH</code> Update Partially updates an existing resource. The request only contains the resource modifications instead of the full resource representation. <code>DELETE</code> Delete Remove a resource with the given URI."},{"location":"api-design-rules/#examples","title":"Examples","text":"<p>The following table shows some examples of the use of standard HTTP methods:</p> Request Description <code>GET /Patient</code> Retrieves a list of patients. <code>GET /Patient/12</code> Retrieves an individual patient. <code>POST /Patient</code> Creates a new patient. <code>PUT /Patient/12</code> Modifies Patient #12 completely. <code>PATCH /Patient/12</code> Modifies Patient #12 partially. <code>DELETE /Patient/12</code> Deletes Patient #12. <p>HTTP also defines other methods, e.g., <code>HEAD</code>, <code>OPTIONS</code> and <code>TRACE</code>. For this design rule, these operations are left out of scope.</p>"},{"location":"api-design-rules/#dr003-developers-must-adhere-to-http-safety-and-idempotency-semantics-for-operations","title":"DR003: Developers MUST adhere to HTTP safety and idempotency semantics for operations","text":"<p>The HTTP protocol (RFC 7231) specifies whether an HTTP method should be considered safe and/or idempotent. These characteristics are important for clients and middleware applications because they should be considered when implementing caching and fault tolerance strategies.</p> <p>Request methods are considered safe if their defined semantics are essentially read-only, i.e., the client does not request, and does not expect, any state change on the origin server because of applying a safe method to a target resource. A request method is considered idempotent if the intended effect on the server of multiple identical requests with that method is the same as the effect for a single such request.</p> Applicable roles API server developer Standardization levels TSA, FSA Status Final Since version 1.0.0 Dutch National API strategy API-01"},{"location":"api-design-rules/#sub-requirements_1","title":"Sub-requirements","text":"<ul> <li>DR003.001: HTTP <code>GET</code> method MUST behave as safe</li> <li>DR003.002: HTTP <code>GET</code> method MUST behave as idempotent</li> <li>DR003.003: HTTP <code>HEAD</code> method MUST behave as safe</li> <li>DR003.004: HTTP <code>HEAD</code> method MUST behave as idempotent</li> <li>DR003.005: HTTP <code>OPTIONS</code> method MUST behave as safe</li> <li>DR003.006: HTTP <code>OPTIONS</code> method MUST behave as idempotent</li> <li>DR003.007: HTTP <code>POST</code> method MUST NOT behave as safe</li> <li>DR003.008: HTTP <code>POST</code> method MUST NOT behave as idempotent</li> <li>DR003.009: HTTP <code>PUT</code> method MUST NOT behave as safe</li> <li>DR003.010: HTTP <code>PUT</code> method MUST behave as idempotent</li> <li>DR003.011: HTTP <code>PATCH</code> method MUST NOT behave as safe</li> <li>DR003.012: HTTP <code>PATCH</code> method MUST NOT behave as idempotent</li> <li>DR003.013: HTTP <code>DELETE</code> method MUST NOT behave as safe</li> <li>DR003.014: HTTP <code>DELETE</code> method MUST behave as idempotent</li> </ul> <p>The following table describes which HTTP methods must behave as safe and/or idempotent:</p> Method Safe Idempotent <code>GET</code> Yes Yes <code>HEAD</code> Yes Yes <code>OPTIONS</code> Yes Yes <code>POST</code> No No <code>PUT</code> No Yes <code>PATCH</code> No No <code>DELETE</code> No Yes"},{"location":"api-design-rules/#dr004-server-communication-must-remain-stateless","title":"DR004: Server communication MUST remain stateless","text":"<p>One of the key constraints of the REST architectural style is stateless communication between client and server. It means that every request from client to server must contain all the information necessary to understand the request. The server cannot take advantage of any stored session context on the server as it didn't memorize previous requests. Session state must therefore reside entirely on the client.</p> Applicable roles API server developer Standardization levels TSA, FSA Status Final Since version 1.0.0 <p>To properly understand this constraint, it's important to make a distinction between two distinct kinds of state:</p> <ul> <li>Session state: information about the interactions of an end-user with a particular client application within the   same user session, such as the last page being viewed, the login state or form data in a multi-step registration   process. Session state must reside entirely on the client (e.g., in the user's browser).</li> <li>Resource state: information that is permanently stored on the server beyond the scope of a single user session, such   as the user's profile, a product purchase or information about a building. Resource state is persisted on the server   and must be exchanged between client and server (in both directions) using representations as part of the request or   response payload. This is where the term REpresentational State Transfer (REST) originates from.</li> </ul> <p>It's a misconception that there should be no state at all. The stateless communication constraint should be seen from the server's point of view and states that the server should not be aware of any session state.</p> <p>Stateless communication offers many advantages, including:</p> <ul> <li>Simplicity is increased because the server doesn't have to memorize or retrieve the session state while processing   requests</li> <li>Scalability is improved because not having to incorporate the session state across multiple requests enables higher   concurrency and performance</li> <li>Observability is improved since every request can be monitored or analysed in isolation without having to incorporate   session context from other requests</li> <li>Reliability is improved because it simplifies the task of recovering from partial failures since the server doesn't   have to maintain, update or communicate the session state. One failing request does not influence other requests   (depending on the nature of the failure of course).</li> </ul> <p>In the context of REST APIs, the server must not maintain or require any notion of the functionality of the client application and the corresponding end-user interactions. To achieve full decoupling between client and server, and to benefit from the advantages mentioned above, no session state must reside on the server. Session state must therefore reside entirely on the client.</p> <p>The client of a REST API could be a variety of applications such as a browser application, a mobile or desktop application or even another server serving as a backend component for another client. REST APIs should therefore be completely client agnostic.</p>"},{"location":"api-design-rules/#dr005-content-relationship-must-be-predictably-implemented","title":"DR005: Content relationship MUST be predictably implemented","text":"Applicable roles API server developer Standardization levels OA, TSA, FSA Status Final Since version 1.0.0"},{"location":"api-design-rules/#sub-requirements_2","title":"Sub-requirements","text":"<ul> <li>DR005.001: When using several content relationships within an API, adding more relationships MUST adhere to   the same implementation choices<ul> <li>For example, if a child resource is already available through stacking of endpoint, another child resource must be   made available in the same manner.</li> </ul> </li> </ul>"},{"location":"api-design-rules/#dr006-operations-must-be-predictably-implemented","title":"DR006: Operations MUST be predictably implemented","text":"<p>An API can be made more accessible using operations.</p> Applicable roles API server developer Standardization levels OA, TSA, FSA Status Final Since version 1.0.0"},{"location":"api-design-rules/#sub-requirements_3","title":"Sub-requirements","text":"<ul> <li>DR006.001: The operations in one API MUST all be implemented in the same way<ul> <li>For example, if an operation is called with a prefix, the same prefix must be used for every other operation on   the same API.</li> </ul> </li> </ul>"},{"location":"api-design-rules/#dr007-api-version-must-be-accessible-through-the-api","title":"DR007: API version MUST be accessible through the API","text":"<p>The version of an API can be useful in development and debugging.</p> Applicable roles API server developer Standardization levels OA, TSA, FSA Status Final Since version 1.0.0"},{"location":"api-design-rules/#sub-requirements_4","title":"Sub-requirements","text":"<ul> <li>DR007.001: The API version MAY be made accessible through the URL-path<ul> <li>For example, <code>/v1/api/...</code></li> </ul> </li> <li>DR007.002: The API version MAY be made accessible through a HTTP header<ul> <li>For example, in <code>Accept</code> (request) and <code>Content-Type</code> (response).</li> </ul> </li> <li>DR007.003: The API version MAY be made accessible through a separate request<ul> <li>For example, in response to <code>/api/version</code></li> </ul> </li> <li>DR007.004: The API version MAY be made accessible through the API in a way not covered in this specification</li> </ul>"},{"location":"api-design-rules/#dr008-apis-must-at-least-support-the-deflate-and-gzip-compression-algorithms","title":"DR008: APIs MUST at least support the DEFLATE and gzip compression algorithms","text":"<p>The use of compression algorithms can reduce communication size. This is especially useful when transferring large data objects. The algorithms DEFLATE and gzip are widely used in HTTP communication.</p> Applicable roles API server developer Standardization levels TSA, FSA Status Final Since version 1.0.0"},{"location":"api-design-rules/#dr009-apis-must-support-the-use-of-http-accept-encoding-and-content-encoding-header-fields-for-negotiating-compression","title":"DR009: APIs MUST support the use of HTTP Accept-Encoding and Content-Encoding header fields for negotiating compression","text":"<p>The <code>Accept-Encoding</code> and <code>Content-Encoding</code> header fields are used to negotiate the compression algorithms. The API client will use the <code>Accept-Encoding</code> header field to communicate which compression algorithms are supported. The API server will use the <code>Content-Encoding</code> header field to confirm which compression algorithm is used.</p> Applicable roles API client developer, API server developer Standardization levels TSA, FSA Status Final Since version 1.0.0"},{"location":"api-design-rules/#dr011-json-formatted-content-should-comply-to-rfc-8259-or-its-successor","title":"DR011: JSON formatted content SHOULD comply to RFC 8259 or its successor","text":"<p>The design of JSON is described by IETF in RFC 8259. Any use of JSON SHOULD be compliant with this RFC or its successor.</p> Applicable roles API server developer Standardization levels TSA, FSA Status Final Since version 1.0.0"},{"location":"api-design-rules/#dr012-when-describing-an-api-where-data-is-being-transferred-to-another-party-the-notified-pull-exchange-pattern-should-be-used-rather-than-the-push-exchange-pattern","title":"DR012: When describing an API where data is being transferred to another party, the NOTIFIED PULL exchange pattern SHOULD be used rather than the PUSH exchange pattern","text":"<p>This way, the receiving party can decide when or how the transferred data is received and processed.</p> Applicable roles API specifier Standardization levels TSA, FSA Status Final Since version 1.0.0"},{"location":"api-design-rules/#dr013-system-apis-should-be-designed-independent-of-specific-use-cases-and-types-of-client-systems-or-users","title":"DR013: System APIs SHOULD be designed independent of specific use cases and types of client systems or users","text":"<p>Making the System APIs independent of a specific use case encourages the reuse of these APIs.</p> Applicable roles API server developer Standardization levels TSA, FSA Status Final Since version 1.0.0"},{"location":"api-design-rules/#dr014-process-apis-should-be-designed-to-reuse-system-apis","title":"DR014: Process APIs SHOULD be designed to reuse System APIs","text":"<p>Process APIs make use of the System APIs. It is encouraged to reuse already existing System APIs.</p> Applicable roles API server developer Standardization levels TSA, FSA Status Final Since version 1.0.0"},{"location":"api-design-rules/#dr015-experience-apis-should-be-based-on-process-apis","title":"DR015: Experience APIs SHOULD be based on Process APIs","text":"<p>Experience APIs are by definition based on Process APIs, this SHOULD always be the case.</p> Applicable roles API server developer Standardization levels TSA, FSA Status Final Since version 1.0.0"},{"location":"api-design-rules/#dr016-system-apis-should-be-based-on-the-operations-messaging-or-resource-paradigm-rather-than-the-document-paradigm","title":"DR016: System APIs SHOULD be based on the operations, messaging, or resource paradigm rather than the document paradigm","text":"<p>To be fully atomic the document paradigm SHOULD be avoided in system APIs.</p> Applicable roles API server developer Standardization levels TSA, FSA Status Final Since version 1.0.0"},{"location":"api-design-rules/#soap","title":"SOAP","text":""},{"location":"api-design-rules/#dr-s001-apis-may-use-mtomxop-for-formatting-binary-data","title":"DR-S001: APIs MAY use MTOM/XOP for formatting binary data","text":"<p>When a SOAP message contains a large binary object, it can be optimized for processing by using MTOM/XOP. APIs MAY use MTOM/XOP to create a multipart MIME to link from the SOAP body to a mime part which holds the binary data.</p> Applicable roles API specifier Standardization levels TSA, FSA Status Final Since version 1.0.0"},{"location":"api-design-rules/#dr-s002-api-clients-must-support-mtomxop-formatting-of-binary-data","title":"DR-S002: API clients MUST support MTOM/XOP formatting of binary data","text":"<p>Design rule DR-S001 determined that an API MAY use MTOM/XOP when it believes it is necessary to optimize processing of the message. To be able to use these APIs, API clients MUST support MTOM/XOP as well.</p> Applicable roles API client developer Standardization levels TSA, FSA Status Final Since version 1.0.0"},{"location":"api-design-rules/#restful","title":"RESTful","text":"<p>The REST architectural style is centred around the concept of a resource. A resource is the key abstraction of information, where every piece of information is named by assigning a globally unique URI (Uniform Resource Identifier). Resources describe things, which can vary between physical objects (e.g., a building or a person) and more abstract concepts (e.g., a permit or an event).</p>"},{"location":"api-design-rules/#dr-r001-apis-must-use-nouns-to-name-resources","title":"DR-R001: APIs MUST use nouns to name resources","text":"<p>Because resources describe things (and thus not actions), resources are referred to using nouns (instead of verbs) that are relevant from the perspective of the user of the API.</p> Applicable roles API specifier Standardization levels TSA, FSA Status Final Since version 1.0.0 Dutch National API strategy API-05"},{"location":"api-design-rules/#examples_1","title":"Examples","text":"<p>A few correct examples of nouns as part of FHIR:</p> <ul> <li>Patient</li> <li>Observation</li> <li>AllergyIntolerance</li> </ul>"},{"location":"api-design-rules/#dr-r002-apis-must-use-singular-nouns-to-name-collection-resources","title":"DR-R002: APIs MUST use singular nouns to name collection resources","text":"<p>Resources can be grouped into collections, which are resources in their own right and can typically be paged, sorted and filtered. Most often all collection members have the same type, but this is not necessarily the case. A resource describing multiple things is called a collection resource. Collection resources typically contain references to the underlying singular resources. A collection resource could still contain only one contained resource, therefore the path segment describing the name of the collection resource MUST be written in the singular form.</p> Applicable roles API specifier Standardization levels TSA, FSA Status Final Since version 1.0.0 <p>A collection resource could still contain only one contained resource, therefore the path segment describing the name of the collection resource MUST be written in the singular form.</p>"},{"location":"api-design-rules/#examples_2","title":"Examples","text":"<p>Example of how to collect a collection of resources in FHIR:</p> <ul> <li><code>https://api.example.org/Patient</code></li> <li><code>https://api.example.org/Observation?code=http://loinc.org|29463-7</code></li> </ul>"},{"location":"api-design-rules/#dr-r003-apis-must-hide-irrelevant-implementation-details","title":"DR-R003: APIs MUST hide irrelevant implementation details","text":"<p>An API should not expose implementation details of the underlying application. The primary motivation behind this design rule is that an API design must focus on usability for the client, regardless of the implementation details under the hood. The API, application and infrastructure need to be able to evolve independently to ease the task of maintaining backwards compatibility for APIs during an agile development process.</p> Applicable roles API server developer Standardization levels TSA, FSA Status Final Since version 1.0.0 Dutch National API strategy API-53"},{"location":"api-design-rules/#examples_3","title":"Examples","text":"<p>A few examples of implementation details:</p> <ul> <li>The API design should not necessarily be a 1-to-1 mapping of the underlying domain or persistence model</li> <li>The API should not expose information about the technical components being used, such as development   platforms/frameworks or database systems</li> <li>The API should offer client-friendly attribute names and values, while persisted data may contain abbreviated terms or   serializations which might be cumbersome for consumption</li> </ul>"},{"location":"api-design-rules/#dr-r004-apis-must-support-both-json-and-xml-formatting","title":"DR-R004: APIs MUST support both JSON and XML formatting","text":"<p>JSON and XML both have their advantages and disadvantages. API clients can focus on either standard for all their API calls when all APIs support both. Therefore, APIs MUST support both JSON and XML formatting.</p> Applicable roles API server developer Standardization levels TSA, FSA Status Final Since version 1.0.0"},{"location":"api-design-rules/#sub-requirements_5","title":"Sub-requirements","text":"<ul> <li>DR-R004.001: APIs MUST be able to convert consistently between JSON and XML formatting<ul> <li>Converting from one to the other and back to the first MUST result in the exact same resource.</li> </ul> </li> </ul>"},{"location":"api-design-rules/#dr-r005-api-clients-must-at-least-support-json-or-xml-formatting","title":"DR-R005: API clients MUST at least support JSON or XML formatting","text":"<p>As described in DR-R004, both JSON and XML will be supported from the APIs. API clients MUST therefore at least support one of the two formats. In the end this means the focus can be on either XML or JSON for all calls to available APIs.</p> Applicable roles API client developer Standardization levels TSA, FSA Status Final Since version 1.0.0"},{"location":"api-design-rules/#dr-r006-apis-may-support-bson-formatting","title":"DR-R006: APIs MAY support BSON formatting","text":"<p>BSON are used to communicate JSON in a binary object. This is an innovative technology that could improve performance in larger JSON objects. APIs MAY therefore support BSON formatting.</p> Applicable roles API server developer Standardization levels TSA, FSA Status Final Since version 1.0.0"},{"location":"api-design-rules/#dr-r007-apis-must-use-the-accept-header-for-content-negotiation","title":"DR-R007: APIs MUST use the Accept header for content negotiation","text":"<p>The HTTP header <code>Accept</code> is used to communicate which content types can be understood by the API clients.</p> Applicable roles API server developer, API client developer Standardization levels TSA, FSA Status Final Since version 1.0.0"},{"location":"api-design-rules/#sub-requirements_6","title":"Sub-requirements","text":"<ul> <li>DR-R007.001: The API client MUST use the <code>Accept</code> header to communicate which content types the client is able   to understand</li> <li>DR-R007.002: The API server MUST use the <code>Accept</code> header value to decide the response content type</li> </ul>"},{"location":"api-design-rules/#dr-r008-apis-must-use-the-content-type-header-for-content-negotiation","title":"DR-R008: APIs MUST use the Content-Type header for content negotiation","text":"<p>The HTTP header <code>Content-Type</code> is used to communicate which content type is used in communication between client and server.</p> Applicable roles API server developer, API client developer Standardization levels TSA, FSA Status Final Since version 1.0.0"},{"location":"api-design-rules/#sub-requirements_7","title":"Sub-requirements","text":"<ul> <li>DR-R008.001: The API server MUST use the <code>Content-Type</code> header to communicate the content type</li> <li>DR-R008.002: The API client MUST use the <code>Content-Type</code> header value to decide how to process the response</li> </ul>"},{"location":"api-discoverability/","title":"API discoverability","text":""},{"location":"api-discoverability/#di001-api-specifications-should-be-published-in-the-dutch-api-library-for-healthcare","title":"DI001: API specifications SHOULD be published in the Dutch API library for healthcare","text":"Applicable roles API specifier Standardization levels OA, TSA, FSA Status Final Since version 1.0.0"},{"location":"api-discoverability/#sub-requirements","title":"Sub-requirements","text":"<ul> <li>DI001.001: The API specifier MUST specify the status of each version of its API specification published in the   Dutch API library for healthcare</li> <li>DI001.002: The API specifier MUST provide (a link to) all specification, documentation and qualification   documents available for each version of its API specification published in the Dutch API library for healthcare</li> <li>DI001.003: API specifications that are published in the Dutch API library for healthcare MUST at least comply   with all requirements for Open APIs (Open API standardization level) that apply to the API specifier role</li> </ul>"},{"location":"api-discoverability/#di002-api-implementations-should-be-published-in-the-dutch-api-library-for-healthcare","title":"DI002: API implementations SHOULD be published in the Dutch API library for healthcare","text":"Applicable roles API server developer Standardization levels OA, TSA, FSA Status Final Since version 1.0.0"},{"location":"api-discoverability/#sub-requirements_1","title":"Sub-requirements","text":"<ul> <li>DI002.001: The API server developer MUST specify the status of each version of its API implementation   published in the Dutch API library for healthcare</li> <li>DI002.002: The API server developer MUST provide the name and version of the system that contains the API   implementation for each version of its API implementation published in the Dutch API library for healthcare</li> <li>DI002.003: API implementations that are published in the Dutch API library for healthcare MUST refer to (one   or more versions of) an API specification that is published in the Dutch API library for healthcare</li> <li>DI002.004: API implementations that are published in the Dutch API library for healthcare MUST at least comply   with all requirements for Open APIs (Open API standardization level) that apply to the API server developer role</li> </ul>"},{"location":"api-discoverability/#di003-api-deployments-should-be-published-in-the-dutch-api-library-for-healthcare","title":"DI003: API deployments SHOULD be published in the Dutch API library for healthcare","text":"Applicable roles API server deployer Standardization levels OA, TSA, FSA Status Final Since version 1.0.0"},{"location":"api-discoverability/#sub-requirements_2","title":"Sub-requirements","text":"<ul> <li>DI003.001: The API server deployer MUST specify the status of each version of its API deployment published in   the Dutch API library for healthcare</li> <li>DI003.002: The API server deployer MUST provide (a link to) all information considering agreements and   conditions for using the API, onboarding and testing procedures and endpoint information for each version of its API   deployment published in the Dutch API library for </li> <li>DI003.003: API deployments that are published in the Dutch API library for healthcare MUST refer to an API   implementation that is published in the Dutch API library for healthcare</li> <li>DI003.004: API deployments that are published in the Dutch API library for healthcare MUST at least comply   with all requirements for Open APIs (Open API standardization level) that apply to the API server deployer role</li> </ul>"},{"location":"api-lifecycle-management-and-versioning/","title":"API Lifecycle management and versioning","text":""},{"location":"api-lifecycle-management-and-versioning/#lm001-api-specifications-must-be-marked-deprecated-when-they-are-no-longer-recommended-for-use","title":"LM001: API specifications MUST be marked deprecated when they are no longer recommended for use","text":"Applicable roles API specifier Standardization levels OA, TSA, FSA Status Final Since version 1.0.0"},{"location":"api-lifecycle-management-and-versioning/#sub-requirements","title":"Sub-requirements","text":"<ul> <li>LM001.001: An API specifier MUST mark an API specification as deprecated (in the Dutch API library for   healthcare) when it is no longer recommended for use<ul> <li>Specifications marked as deprecated are still supported but support may end soon.</li> </ul> </li> <li>LM001.002: An API specifier MUST mark an API specification as deprecated for a period of at least one year,   before it MAY be marked retired</li> <li>LM001.003: API server developers SHOULD replace the use of deprecated API specifications with newer versions   or alternative API specifications</li> <li>LM001.004: API server developers MUST mark API implementations as deprecated (in the Dutch API library for   healthcare) when they are based on a deprecated API specification</li> </ul>"},{"location":"api-lifecycle-management-and-versioning/#lm002-api-specifications-must-be-marked-retired-when-they-are-no-longer-supported","title":"LM002: API specifications MUST be marked retired when they are no longer supported","text":"Applicable roles API specifier Standardization levels OA, TSA, FSA Status Final Since version 1.0.0"},{"location":"api-lifecycle-management-and-versioning/#sub-requirements_1","title":"Sub-requirements","text":"<ul> <li>LM002.001: An API specifier MUST mark an API specification as retired (in the Dutch API library for   healthcare) when it is no longer supported</li> <li>LM002.002: API server developers MUST replace the use of retired API specifications with newer versions or   alternative API specifications</li> <li>LM002.003: API server developers MUST mark API implementations as retired when they are based on a retired API   specification</li> </ul>"},{"location":"api-lifecycle-management-and-versioning/#lm003-api-implementations-must-be-marked-deprecated-when-they-are-no-longer-recommended-for-use","title":"LM003: API implementations MUST be marked deprecated when they are no longer recommended for use","text":"Applicable roles API server developer Standardization levels OA, TSA, FSA Status Final Since version 1.0.0"},{"location":"api-lifecycle-management-and-versioning/#sub-requirements_2","title":"Sub-requirements","text":"<ul> <li>LM003.001: An API server developer MUST mark an API implementation as deprecated (in the Dutch API library for   healthcare) when it is no longer recommended for use<ul> <li>Implementations marked as deprecated are still supported but support may end soon.</li> </ul> </li> <li>LM003.002: An API server developer MUST mark an API implementation as deprecated for a period of at least one   year, before it MAY be marked retired</li> <li>LM003.003: API server deployers SHOULD replace deprecated API implementations with newer versions or   alternative API implementations</li> <li>LM003.004: API server deployers MUST mark an API deployment as deprecated (in the Dutch API library for   healthcare) when it is based on a deprecated implementation</li> </ul>"},{"location":"api-lifecycle-management-and-versioning/#lm004-api-implementations-must-be-marked-retired-when-they-are-no-longer-supported","title":"LM004: API implementations MUST be marked retired when they are no longer supported","text":"Applicable roles API server developer Standardization levels OA, TSA, FSA Status Final Since version 1.0.0"},{"location":"api-lifecycle-management-and-versioning/#sub-requirements_3","title":"Sub-requirements","text":"<ul> <li>LM004.001: An API server developer MUST mark an API implementation as retired (in the Dutch API library for   healthcare) when it is no longer supported</li> <li>LM004.002: API server deployers MUST replace the use of retired API implementations with newer versions or   alternative API implementations</li> <li>LM004.003: API server deployers MUST mark API deployments as retired (in the Dutch API library for healthcare)   when they are based on a retired API implementation</li> </ul>"},{"location":"api-lifecycle-management-and-versioning/#lm005-api-deployments-must-be-marked-deprecated-when-they-are-no-longer-recommended-for-use","title":"LM005: API deployments MUST be marked deprecated when they are no longer recommended for use","text":"Applicable roles API server deployer Standardization levels OA, TSA, FSA Status Final Since version 1.0.0"},{"location":"api-lifecycle-management-and-versioning/#sub-requirements_4","title":"Sub-requirements","text":"<ul> <li>LM005.001: An API server deployer MUST mark an API deployment as deprecated (in the Dutch API library for   healthcare) when it is no longer recommended for use<ul> <li>Deployments marked as deprecated are still supported but support may end soon.</li> </ul> </li> <li>LM005.002: An API server deployer MUST mark an API deployment as deprecated for a period of at least one year,   before it MAY be marked retired</li> <li>LM005.003: API client developers SHOULD replace the use of deprecated API employments with newer versions or   alternative API implementations</li> </ul>"},{"location":"api-lifecycle-management-and-versioning/#lm006-api-deployments-must-be-marked-retired-when-they-are-no-longer-supported","title":"LM006: API deployments MUST be marked retired when they are no longer supported","text":"Applicable roles API server deployer Standardization levels OA, TSA, FSA Status Final Since version 1.0.0"},{"location":"api-lifecycle-management-and-versioning/#sub-requirements_5","title":"Sub-requirements","text":"<ul> <li>LM006.001: An API server deployer MUST mark an API deployment as retired (in the Dutch API library for   healthcare) when it is no longer supported</li> <li>LM006.002: API client developers MUST replace the use of retired API deployments with newer versions or   alternative API deployments</li> </ul>"},{"location":"api-lifecycle-management-and-versioning/#lm007-an-api-client-must-be-designed-to-handle-non-breaking-changes","title":"LM007: An API client MUST be designed to handle non-breaking changes","text":"<p>This includes at least the non-breaking changes described in Non-breaking changes.</p> <p>Non-breaking changes are changes that cannot be expected to break a client application. Adding optional parts to an API is never considered a breaking change.</p> Applicable roles API client deployer Standardization levels OA, TSA, FSA Status Final Since version 1.0.0"},{"location":"api-lifecycle-management-and-versioning/#sub-requirements_6","title":"Sub-requirements","text":"<ul> <li>LM007.001: An API client MUST be designed to handle addition of new endpoints</li> <li>LM007.002: An API client MUST be designed to handle addition of new resources or operations to existing   endpoints</li> <li>LM007.003: An API client MUST be designed to handle addition of new fields in responses</li> <li>LM007.004: An API client MUST be designed to handle addition of new optional request fields or parameters</li> <li>LM007.005: An API client MUST be designed to handle addition of new required request fields that have default   values</li> <li>LM007.006: An API client MUST be designed to handle addition of optional query parameters</li> <li>LM007.007: An API client MUST be designed to handle changes to the order of fields returned within a response</li> <li>LM007.008: An API client MUST be designed to handle addition of an optional request header</li> <li>LM007.009: An API client MUST be designed to handle removal of redundant request header</li> <li>LM007.010: An API client MUST be designed to handle changes to the overall response size</li> <li>LM007.011: An API client MUST be designed to handle changes to error messages</li> </ul>"},{"location":"api-lifecycle-management-and-versioning/#lm008-an-api-specification-must-comply-with-semantic-versioning-specification-semver-version-200","title":"LM008: An API specification MUST comply with Semantic Versioning specification (SemVer) version 2.0.0","text":"Applicable roles API specifier Standardization levels OA, TSA, FSA Status Final Since version 1.0.0"},{"location":"api-onboarding/","title":"API onboarding","text":""},{"location":"api-onboarding/#ob001-all-api-onboarding-policies-criteria-and-procedures-must-be-documented","title":"OB001: All API onboarding policies, criteria and procedures MUST be documented","text":"Applicable roles API server deployer Standardization levels OA, TSA, FSA Status Final Since version 1.0.0"},{"location":"api-onboarding/#sub-requirements","title":"Sub-requirements","text":"<ul> <li>OB001.001: API documentation MUST include details of the onboarding process, including criteria and policies   for onboarding approval and disapproval</li> <li>OB001.002: When the onboarding process requires a review of the client software and/or API client developer   organization, the documentation MUST include details on the review process</li> </ul>"},{"location":"api-onboarding/#ob002-api-onboarding-should-be-an-online-self-service-process","title":"OB002: API onboarding SHOULD be an online self-service process","text":"<p>To speed up the onboarding process.</p> Applicable roles API server deployer Standardization levels OA, TSA, FSA Status Final Since version 1.0.0"},{"location":"api-onboarding/#sub-requirements_1","title":"Sub-requirements","text":"<ul> <li>OB002.001: An online service SHOULD be used to submit all the information required to onboard the API client   developer and/or client system</li> </ul>"},{"location":"api-onboarding/#ob003-api-onboarding-may-require-a-review-of-the-client-system-and-api-client-developer-organization","title":"OB003: API onboarding MAY require a review of the client system and API client developer organization","text":"Applicable roles API server deployer Standardization levels OA, TSA, FSA Status Final Since version 1.0.0"},{"location":"api-onboarding/#sub-requirements_2","title":"Sub-requirements","text":"<ul> <li>OB003.001: The API onboarding process MAY include a review of the client system and of the organizations that   develop and/or deploy the API client</li> <li>OB003.002: An API server deployer MAY require an external review of the API client software, such as a   security review, as part of the API onboarding procedure</li> <li>OB003.003: An API server deployer MAY require external certification of the Quality Management System (QMS)   and/or Information Security Management System (ISMS) used by organizations that develop and/or deploy the API client   as part of the API onboarding procedure</li> </ul>"},{"location":"api-onboarding/#ob004-when-api-onboarding-requires-the-api-client-developer-to-provide-information-on-the-client-system-andor-client-developer-organization-the-api-server-deployer-must-provide-an-information-disclosure-statement","title":"OB004: When API onboarding requires the API client developer to provide information on the client system and/or client developer organization, the API server deployer MUST provide an Information Disclosure Statement","text":"Applicable roles API server deployer Standardization levels OA, TSA, FSA Status Final Since version 1.0.0"},{"location":"api-onboarding/#sub-requirements_3","title":"Sub-requirements","text":"<ul> <li>OB004.001: The Information Disclosure Statement MUST explicitly state what information is considered   confidential and what information is NOT considered confidential</li> <li>OB004.002: The Information Disclosure Statement MUST explicitly state what information is permanently   destroyed, and what information is not, after offboarding</li> <li>OB004.003: The Information Disclosure Statement MUST explicitly state to which other parties information is   supplied and for what purpose</li> <li>OB004.004: The Information Disclosure Statement MUST explicitly state any restrictions on the time period that   the statement is considered in effect</li> </ul>"},{"location":"api-onboarding/#ob005-the-api-server-deployer-must-provide-a-procedure-for-offboarding-an-api-client-andor-organization-responsible-for-developing-andor-deploying-an-api-client","title":"OB005: The API server deployer MUST provide a procedure for offboarding an API client and/or organization responsible for developing and/or deploying an API client","text":"Applicable roles API server deployer Standardization levels OA, TSA, FSA Status Final Since version 1.0.0"},{"location":"api-onboarding/#sub-requirements_4","title":"Sub-requirements","text":"<ul> <li>OB005.001: After offboarding, the API server deployer MUST remove any public (published) statements that   indicate active onboarding by the API client and/or API client organization</li> <li>OB005.002: The API server deployer MAY store information that was previously submitted as part of the API   onboarding process for an unlimited period of time, even after API offboarding</li> </ul>"},{"location":"api-onboarding/#ob006-all-api-offboarding-policies-criteria-and-procedures-must-be-documented","title":"OB006: All API offboarding policies, criteria and procedures MUST be documented","text":"Applicable roles API server deployer Standardization levels OA, TSA, FSA Status Final Since version 1.0.0"},{"location":"api-onboarding/#sub-requirements_5","title":"Sub-requirements","text":"<ul> <li>OB006.001: API documentation MUST include details of the offboarding process, including criteria and policies   for offboarding, initiated by the API server deployer</li> </ul>"},{"location":"api-security/","title":"API security","text":""},{"location":"api-security/#generic","title":"Generic","text":""},{"location":"api-security/#sc001-api-specifications-must-comply-with-dutch-ncsc-guidelines-for-web-applications","title":"SC001: API specifications MUST comply with Dutch NCSC guidelines for web applications","text":"<p>The Dutch governmental organization NCSC (National Cyber Security Centre) has specified IT Security Guidelines for Web Applications (Dutch). The API specifications MUST comply with these guidelines.</p> <p>Compliance check will be limited to a confirmation by the specifier.</p> Applicable roles API specifier Standardization levels OA, TSA, FSA Status Final Since version 1.0.0"},{"location":"api-security/#sc002-api-implementations-must-comply-with-dutch-ncsc-guidelines-for-web-applications","title":"SC002: API implementations MUST comply with Dutch NCSC guidelines for web applications","text":"<p>The Dutch governmental organization NCSC (National Cyber Security Centre) has specified IT Security Guidelines for Web Applications (Dutch). The API implementations MUST comply with these guidelines.</p> <p>Compliance check will be limited to a confirmation by the server developer.</p> Applicable roles API server developer Standardization levels OA, TSA, FSA Status Final Since version 1.0.0"},{"location":"api-security/#sc003-api-deployments-must-comply-with-dutch-ncsc-guidelines-for-web-applications","title":"SC003: API deployments MUST comply with Dutch NCSC guidelines for web applications","text":"<p>The Dutch governmental organization NCSC (National Cyber Security Centre) has specified IT Security Guidelines for Web Applications (Dutch). The API deployments MUST comply with these guidelines.</p> <p>Compliance check will be limited to a confirmation by the server deployer.</p> Applicable roles API server deployer Standardization levels OA, TSA, FSA Status Final Since version 1.0.0"},{"location":"api-security/#sc004-api-deployments-must-comply-with-dutch-ncsc-guidelines-for-transport-layer-security","title":"SC004: API deployments MUST comply with Dutch NCSC guidelines for Transport Layer Security","text":"<p>The Dutch governmental organization NCSC (National Cyber Security Centre) has specified IT Security Guidelines for Transport Layer Security (TLS). The API deployments MUST comply with these guidelines.</p> <p>Compliance check will be limited to a confirmation by the server deployer.</p> Applicable roles API server deployer Standardization levels OA, TSA, FSA Status Final Since version 1.0.0"},{"location":"api-security/#sub-requirements","title":"Sub-requirements","text":"<ul> <li>SC004.001: The status of used TLS versions, algorithms, key size &amp; choice of groups and options SHOULD at   least be Sufficient<ul> <li>The secure configuration of TLS is important to secure network connections. TLS has secure and less secure   settings. Legacy software does not always support the most secure settings. Use Good settings when possible and   complement these with Sufficient settings to support legacy software. Do you need to support a lot of legacy   software? Then use a broad palette of Sufficient settings and complement it with Good settings where possible. Use   Phase out settings only whilst you have a further need for client compatibility and set clear criteria for their   deprecation. Do not use Insufficient settings.</li> </ul> </li> </ul>"},{"location":"api-security/#sc005-an-api-must-provide-audit-logging-conforming-to-nen-7513","title":"SC005: An API MUST provide audit logging conforming to NEN 7513","text":"<p>The audit logging should conform to what is described in NEN 7513, at least the content matches to what is described in the same NEN 7513.</p> Applicable roles API server deployer Standardization levels OA, TSA, FSA Status Final Since version 1.0.0"},{"location":"api-security/#sc006-specifications-for-system-apis-must-use-authentication-and-authorization-models-that-are-not-specific-to-a-use-case-or-type-of-client-or-user","title":"SC006: Specifications for 'System APIs' MUST use authentication and authorization models that are not specific to a use case or (type of) client or user","text":"<p>To ensure the disconnection between System APIs and other types of APIs, the authentication and authorization models used by System APIs cannot be specific to a use case or (type of) client or user.</p> Applicable roles API specifier Standardization levels TSA, FSA Status Final Since version 1.0.0"},{"location":"api-security/#sc007-apis-must-use-fully-standardized-models-for-identification-and-authentication","title":"SC007: APIs MUST use fully standardized models for identification and authentication","text":"Applicable roles API specifier Standardization levels FSA Status Final Since version 1.0.0"},{"location":"api-security/#sc008-all-tokens-used-for-client-authentication-must-be-signed-using-asymmetrical-encryption","title":"SC008: All tokens used for client authentication MUST be signed using asymmetrical encryption","text":"Applicable roles API specifier Standardization levels TSA, FSA Status Final Since version 1.0.0"},{"location":"api-security/#sc009-when-generic-servicesfunctions-are-nationally-prescribed-for-use-apis-must-use-these-generic-servicesfunctions","title":"SC009: When generic services/functions are nationally prescribed for use, APIs MUST use these generic services/functions","text":"Applicable roles API specifier Standardization levels TSA, FSA Status Final Since version 1.0.0"},{"location":"api-security/#examples","title":"Examples","text":"<p>Examples of generic services/functions could be:</p> <ul> <li>Patient Consent</li> <li>Addressing</li> <li>Authorization models</li> </ul>"},{"location":"api-security/#soap","title":"SOAP","text":""},{"location":"api-security/#sc-s001-apis-should-use-ws-security-to-ensure-message-confidentiality-and-integrity-for-adding-security-tokens","title":"SC-S001: APIs SHOULD use WS-Security to ensure message confidentiality and integrity for adding security tokens","text":"Applicable roles API specifier Standardization levels TSA, FSA Status Final Since version 1.0.0"},{"location":"api-security/#sc-s002-apis-should-use-the-saml-token-security-model","title":"SC-S002: APIs SHOULD use the SAML Token Security Model","text":"<p>SAML is commonly used in SOAP APIs.</p> Applicable roles API specifier Standardization levels TSA, FSA Status Final Since version 1.0.0"},{"location":"api-security/#restful","title":"RESTful","text":""},{"location":"api-security/#sc-r001-apis-must-comply-with-rfc-7523-or-its-successor-for-client-authentication-and-for-requesting-oauth-2-access-tokens","title":"SC-R001: APIs MUST comply with RFC 7523 or its successor for client authentication and for requesting OAuth 2 access tokens","text":"<p>RFC 7523 describes the JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants.</p> Applicable roles API specifier Standardization levels TSA, FSA Status Final Since version 1.0.0"},{"location":"api-security/#sc-r002-apis-should-use-openid-connect-to-achieve-single-sign-on-when-requesting-oauth-access-tokens","title":"SC-R002: APIs SHOULD use OpenID Connect to achieve Single-Sign-On when requesting OAuth access tokens","text":"<p>As far as existing regulations allow.</p> Applicable roles API specifier Standardization levels TSA, FSA Status Final Since version 1.0.0"},{"location":"api-security/#sc-r003-jwt-tokens-used-for-client-authentication-and-authorization-grants-must-comply-with-rfc-7515-and-rfc-7518-or-its-successors","title":"SC-R003: JWT tokens used for client authentication and authorization grants MUST comply with RFC 7515 and RFC 7518, or its successors","text":"<p>RFC 7515 describes the JSON Web Signature (JWS), a data structure representing a digitally signed or MACed (Message Authentication Codes) message.</p> <p>RFC 7518 describes the JSON Web Algorithms (JWA).</p> Applicable roles API specifier Standardization levels TSA, FSA Status Final Since version 1.0.0"},{"location":"api-specification-and-documentation/","title":"API specification &amp; documentation","text":""},{"location":"api-specification-and-documentation/#sd001-api-documentation-must-be-publicly-and-freely-available","title":"SD001: API documentation MUST be publicly and freely available","text":"Applicable roles API specifier Standardization levels OA, TSA, FSA Status Final Since version 1.0.0"},{"location":"api-specification-and-documentation/#sub-requirements","title":"Sub-requirements","text":"<ul> <li>SD001.001: API specification MUST contain enough information for a competent developer to create an API   implementation or an API client without further information</li> <li>SD001.002: API specification MAY refer to other specifications to cover elements</li> <li>SD001.003: API specification MUST cover identification and authentication of people, organizations, and   machines<ul> <li>This does not only apply to the technical standards and specifics used to authenticate entities but also to the   identifying attributes that are used and how to obtain and secure them to create a network of trust.</li> </ul> </li> <li>SD001.004: API specification MUST cover authorization/access control<ul> <li>This does not only apply to the technical standards and specifics used to authorize access to APIs, but also to   the semantics of access tokens and requests for access tokens, such as the permitted values for permissions   (OAuth2 scopes) and expiration requirements.</li> </ul> </li> <li>SD001.005: API specification MUST cover protecting integrity and confidentiality<ul> <li>This applies to any specifics on protecting integrity and confidentiality at both transport and message levels,   including specifics on the cryptographic algorithms, key distribution and PKIs used.</li> </ul> </li> <li>SD001.006: API specification MUST cover addressing<ul> <li>This applies to specifics on addressing API endpoints and mechanisms used to distribute (updates to) addresses.</li> </ul> </li> <li>SD001.007: API specification MUST cover content encoding<ul> <li>This applies to specifics on content encoding such as the compression algorithms used and character encoding.</li> </ul> </li> <li>SD001.008: API specification MUST cover content formatting<ul> <li>Specifics on content formatting such as the use of MTOM/XOP and BSON but also healthcare-specific (data) formats.</li> </ul> </li> <li>SD001.009: API specification MUST cover exchange patterns and exchange paradigms used</li> <li>SD001.010: API specification MUST cover API signature and semantics<ul> <li>All actions (methods) that are available through the API MUST be covered, as well as the legitimate data   structures return (error) codes (the API signature), Including a full specification of all API requests and   responses.</li> </ul> </li> <li>SD001.011: API specification MUST cover use cases<ul> <li>How to (and how not to) use the API in specific use cases.</li> </ul> </li> <li>SD001.012: API specification MUST cover references to other specifications<ul> <li>Most specifications reuse other specifications such as RFCs created by IETF or W3C or Dutch information standards   created by Nictiz.</li> </ul> </li> <li>SD001.013: API documentation MUST be freely available and accessible via a public website</li> <li>SD001.014: API documentation MAY refer to paid content published by standardization organizations</li> <li>SD001.015: Access to API documentation MAY require free registration</li> <li>SD001.016: API documentation MAY be copyright protected</li> <li>SD001.017: Distribution of API documentation without explicit permission of the API specifier MAY be   restricted</li> </ul>"},{"location":"api-specification-and-documentation/#sd002-api-documentation-must-provide-examples-of-how-to-use-the-api","title":"SD002: API documentation MUST provide examples of how to use the API","text":"Applicable roles API specifier Standardization levels OA, TSA, FSA Status Final Since version 1.0.0"},{"location":"api-specification-and-documentation/#sub-requirements_1","title":"Sub-requirements","text":"<ul> <li>SD002.001: API documentation MUST include examples for the most common use cases</li> <li>SD002.002: API documentation MUST clearly express the value of the API (for API client developers and API   users) within the context of the most common use cases</li> <li>SD002.003: When a use case involves integration of two or more APIs, API documentation MUST provide examples   of how to use these APIs in collaboration</li> </ul>"},{"location":"api-specification-and-documentation/#sd003-api-documentation-should-provide-examples-of-input-and-output-data","title":"SD003: API documentation SHOULD provide examples of input and output data","text":"Applicable roles API specifier Standardization levels OA, TSA, FSA Status Final Since version 1.0.0"},{"location":"api-specification-and-documentation/#sub-requirements_2","title":"Sub-requirements","text":"<ul> <li>SD003.001: Documentation for all API methods SHOULD contain examples of input and output data, using a   supported data format such as JSON or XML</li> <li>SD003.002: When the API server developer includes an SDK for easy access to the API, code samples MUST be   provided for using the API through the SDK</li> </ul>"},{"location":"api-specification-and-documentation/#sd004-api-documentation-should-include-a-faq-page-for-api-client-developers","title":"SD004: API documentation SHOULD include a FAQ page for API client developers","text":"Applicable roles API specifier Standardization levels OA, TSA, FSA Status Final Since version 1.0.0"},{"location":"api-specification-and-documentation/#sub-requirements_3","title":"Sub-requirements","text":"<ul> <li>SD004.001: A FAQ SHOULD be made available for developers that want to use the API(s)</li> <li>SD004.002: The FAQ SHOULD be written in an actual question-and-answer format</li> <li>SD004.003: Questions and answers SHOULD be written from the point of view of the API client developer</li> <li>SD004.004: Questions SHOULD include the most common problems and misconceptions that API client developers run   into when using the API</li> </ul>"},{"location":"api-specification-and-documentation/#sd005-api-documentation-may-specify-cases-in-which-api-usage-is-not-applicable","title":"SD005: API documentation MAY specify cases in which API usage is not applicable","text":"Applicable roles API specifier Standardization levels OA, TSA, FSA Status Final Since version 1.0.0"},{"location":"api-specification-and-documentation/#sub-requirements_4","title":"Sub-requirements","text":"<ul> <li>SD005.001: API documentation MAY include cases in which API usage is not applicable or not supported</li> <li>SD005.002: When cases exist in which API usage is not applicable or not supported, API documentation MUST   clearly state whether using the API in this way violates the API license agreement</li> </ul>"},{"location":"api-specification-and-documentation/#sd006-api-server-developers-and-deployers-may-be-active-on-developer-forums-to-assist-api-client-developers-and-deployers-with-the-correct-usage-of-apis","title":"SD006: API server developers and deployers MAY be active on developer forums to assist API client developers and deployers with the correct usage of APIs","text":"<p>Using developer forums, experts can provide resolutions to common hiccups and increase participation and interest for API client developers.</p> Applicable roles API server developer, API server deployer Standardization levels OA, TSA, FSA Status Final Since version 1.0.0"},{"location":"api-specification-and-documentation/#sub-requirements_5","title":"Sub-requirements","text":"<ul> <li>SD006.001: Server developers and deployers MAY be (are encouraged to be) active participants on relevant   developer forums</li> <li>SD006.002: Solutions to problems provided through a developer forum MAY be provided without prejudice</li> <li>SD006.003: API documentation MAY refer to developer forums for knowledge sharing and assistance</li> <li>SD006.004: API server developers and deployers MAY provide their own developer forum</li> </ul>"},{"location":"api-specification-and-documentation/#sd007-api-server-developers-may-provide-api-client-developers-an-sdk-for-easy-access-to-deployed-apis","title":"SD007: API server developers MAY provide API client developers an SDK for easy access to deployed APIs","text":"Applicable roles API server developer Standardization levels OA, TSA, FSA Status Final Since version 1.0.0"},{"location":"api-specification-and-documentation/#sub-requirements_6","title":"Sub-requirements","text":"<ul> <li>SD007.001: If an SDK is provided, it MUST be documented to the extent that a competent developer has   sufficient information to make use of the SDK without further information<ul> <li>Charges for using the SDK are accepted.</li> </ul> </li> <li>SD007.002: If an SDK is provided, API client developers MUST NOT in any way be forced to use it<ul> <li>Any common coding language and/or development platform is accepted.</li> </ul> </li> </ul>"},{"location":"api-specification-and-documentation/#sd008-api-specifications-should-be-machine-readable-and-allow-for-automated-code-generation","title":"SD008: API specifications SHOULD be machine readable and allow for automated code generation","text":"<p>Using machine-readable API specification allows for automated code generation and hence saves time and avoids errors when writing API client code.</p> Applicable roles API server developer Standardization levels OA, TSA, FSA Status Final Since version 1.0.0"},{"location":"api-specification-and-documentation/#sub-requirements_7","title":"Sub-requirements","text":"<ul> <li>SD008.001: API server developers SHOULD provide machine-readable API specifications based on international   standards<ul> <li>Such as OpenAPI (formerly known as Swagger) and/or FHIR StructureDefinitions/OperationDefinitions.</li> </ul> </li> </ul>"},{"location":"api-specification-and-documentation/#sd009-api-documentation-must-be-published-in-english","title":"SD009: API documentation MUST be published in English","text":"Applicable roles API specifier Standardization levels OA, TSA, FSA Status Final Since version 1.0.0"},{"location":"api-specification-and-documentation/#sub-requirements_8","title":"Sub-requirements","text":"<ul> <li>SD009.001: API documentation MUST be available in English</li> <li>SD009.002: Typical Dutch terminology and names of people and organizations MUST be written down in their   original Dutch form</li> <li>SD009.003: Domain concepts MUST be translated to their corresponding official English terms instead of using   literal (word-for-word) translations</li> </ul>"},{"location":"api-specification-and-documentation/#sd010-when-documentation-claims-compliance-to-standards-specifications-guidelines-and-practices-policies-or-law-documentation-must-provide-references-to-evidence-to-back-up-these-claims","title":"SD010: When documentation claims compliance to standards, specifications, guidelines and practices, policies or law, documentation MUST provide (references to) evidence to back up these claims","text":"<p>Examples of evidence include official compliance certificates and statements (such as IHE integration statements and Nictiz qualifications) and independent auditor reports (such as security audit reports).</p> Applicable roles API specifier Standardization levels OA, TSA, FSA Status Final Since version 1.0.0"},{"location":"api-specification-and-documentation/#sd011-content-relationship-must-be-described-in-api-documentation","title":"SD011: Content relationship MUST be described in API documentation","text":"<p>Some content cannot exist without its parent content. The API documentation must describe in which way the relationship is managed and used.</p> Applicable roles API specifier Standardization levels TSA, FSA Status Final Since version 1.0.0"},{"location":"api-specification-and-documentation/#sd012-api-documentation-must-describe-the-availability-and-usage-of-operations","title":"SD012: API documentation MUST describe the availability and usage of operations","text":"<p>API operations can be extremely useful in specific use cases, describing the operations will make them even more useful.</p> Applicable roles API specifier Standardization levels TSA, FSA Status Final Since version 1.0.0"},{"location":"api-specification-and-documentation/#sd013-api-versioning-policy-must-be-documented","title":"SD013: API versioning policy MUST be documented","text":"<p>The versioning of APIs and its policy must be documented in a clear manner. Use of versioning makes developing and debugging by API client developers easier.</p> Applicable roles API specifier Standardization levels TSA, FSA Status Final Since version 1.0.0"},{"location":"api-specification-and-documentation/#sd014-api-specifications-must-cover-the-rationale-behind-the-exchange-paradigm-used-by-the-api","title":"SD014: API specifications MUST cover the rationale behind the exchange paradigm used by the API","text":"<p>Such as described in Exchange paradigms.</p> Applicable roles API specifier Standardization levels FSA Status Final Since version 1.0.0"},{"location":"api-testability/","title":"API testability","text":""},{"location":"api-testability/#ts001-public-test-tooling-must-be-freely-available-for-test-purposes","title":"TS001: Public test tooling MUST be freely available for test purposes","text":"Applicable roles API server deployer Standardization levels OA, TSA, FSA Status Final Since version 1.0.0"},{"location":"api-testability/#sub-requirements","title":"Sub-requirements","text":"<ul> <li>TS001.001: An API server deployer MUST provide test tooling which allows API client developers and API client   deployers to test their solutions without affecting production environments</li> <li>TS001.002: Test tooling MAY be supplied and maintained by API server developers</li> <li>TS001.003: Test tooling and data exposed by test tooling MUST mimic real API usage<ul> <li>Both online and offline tools are accepted.</li> </ul> </li> <li>TS001.004: If online test tooling is supplied, the API server deployer MUST specify what are the Service Level   Agreements for the availability and response times of the test tooling</li> <li>TS001.005: Test tooling MUST NOT expose confidential data, including but not limited to, patient data</li> <li>TS001.006: Test tooling MUST be freely available and accessible via a public website<ul> <li>Free registration to access the test tooling is accepted.</li> </ul> </li> <li>TS001.007: Test tooling MAY be subject to specific onboarding procedures and policies if these policies comply   with onboarding requirements in this specification</li> </ul>"},{"location":"contributing/","title":"How to Contribute","text":"<p>This information will follow soon.</p>"},{"location":"definitions-and-scope/","title":"Definitions and scope","text":""},{"location":"definitions-and-scope/#what-is-an-api","title":"What is an API?","text":"<p>The term 'API' refers to both a formal specification and a piece of software conforming to that specification. Both perspectives are used interchangeably, but although an API specification can exist without its actual implementation in software, the reverse is not possible. On the other hand, a specification without any implementation in actual software does not (yet) represent real value. A third possible perspective is the deployment perspective. In this case an API can be viewed as a service that is deployed by some organization to provide specific value for its clients.</p> <p>No matter the perspective, the purpose of an API is to allow two or more applications to 'talk to each other'. These applications can be located on the same 'machine', or they can be on different remote machines, connected through some kind of network using some kind of communication technology.</p>"},{"location":"definitions-and-scope/#specifications-implementations-and-deployments","title":"Specifications, implementations, and deployments","text":"<p>Due to the different perspectives on what an API is, this specification differentiates between API specifications, API implementations and API deployments.</p>"},{"location":"definitions-and-scope/#api-specification","title":"API specification","text":"<p>An API specification is a formal specification of the API. The specification can be used to construct an API implementation (software) that complies with the specification. It can also be used to develop an API client (more software) that uses the implementation. The API specification can be viewed as a contract between the API implementation and an API client.</p>"},{"location":"definitions-and-scope/#api-implementation","title":"API implementation","text":"<p>An API implementation is the software code that implements the specification. It is (part of) a specific software product created by a specific software developer (organization).</p>"},{"location":"definitions-and-scope/#api-deployment","title":"API deployment","text":"<p>An API deployment is an instance of the software; the actual service deployed by some organization to provide value for its clients. A specific deployment has a specific endpoint address (a URL in most modern APIs) that API clients use to access the API implementation.</p>"},{"location":"definitions-and-scope/#who-uses-an-api","title":"Who uses an API?","text":"<p>API specifications are used by a 'competent developer' to create an API implementation or an API client. A competent developer is a software developer that has experience using the technologies and (healthcare-specific) standards the API exploits and has basic knowledge of the healthcare domain in general and the specific value the API provides.</p> <p>API implementations are used by API clients. Both are pieces of software that need to 'talk to each other'.</p> <p>API deployments are used by API client deployments and form a 'service provider'/'service consumer' pair.</p>"},{"location":"definitions-and-scope/#what-are-api-requirements","title":"What are API requirements?","text":"<p>API requirements are requirements for specifying (API specifications), implementing (API implementations), deploying (API deployments) and using (API clients) an API. In this specification the following conventions are applied when formulating requirements:</p> <ul> <li>An API requirement SHOULD not overlap with existing rules and regulations. Compliance with rules and regulations   is assumed.</li> <li>Even more important, it MUST NOT contradict existing rules and regulations.</li> <li>It SHOULD be reasonably possible to apply to API requirements. A requirement should not require the impossible.</li> </ul> <p>Many requirements have sub-requirements that conform to the same conventions.</p> <p>Whenever possible, requirements in this specification are based on or refer to (inter)national requirements and policies, such as the Dutch National API strategy and national API design rules, international standards and RFCs and policies like the NHS Open API Architecture Policy.</p>"},{"location":"definitions-and-scope/#relationship-with-dutch-health-information-standards","title":"Relationship with (Dutch) Health Information Standards","text":"<p>According to the Dutch competence centre for electronic exchange of health and care information (Nictiz), a Health Information Standard is a cohesive specification of:</p> <ul> <li>A use case or a combination of use cases and interaction patterns</li> <li>Dataset(s) used within these interactions</li> <li>Information models such as HCIMs (Dutch 'Zorg Informatie Bouwstenen' or ZIBs)</li> <li>Terminologies</li> <li>Communication standards such as HL7 CDA and   HL7 FHIR (profiles)</li> </ul> <p>As such, a Health Information Standard does not include technical details that are necessary ingredients of an API specification, such as:</p> <ul> <li>API signature and semantics</li> <li>Identification and authentication of entities</li> <li>Security and transport mechanisms such as addressing</li> <li>Other required technical parts of an API specification and API documentation as described in The contents of an API specification and The contents of API documentation</li> </ul> <p>However, many APIs implement (parts of) Health Information Standards. An API is said to 'implement a Health Information Standard' when its specification, implementation and deployment comply with the requirements of that Health Information Standard.</p>"},{"location":"definitions-and-scope/#relationship-with-the-dutch-api-library-for-healthcare","title":"Relationship with the Dutch API library for healthcare","text":"<p>The Dutch API library for healthcare contains API specifications, implementations and deployments that meet the requirements in this specification at a particular level of standardization (see API levels of standardization). The API library promotes the findability of APIs that meet the requirements in this specification.</p>"},{"location":"definitions-and-scope/#api-lifecycle","title":"API lifecycle","text":"<p>The API lifecycle consists of four phases:</p> <ul> <li>Create: developing the API specification and implementation</li> <li>Deploy: Deploying the API so it can be used by API clients</li> <li>Deprecate: Mark the API specification, implementation, or deployment as being removed at a future date</li> <li>Retire: remove the API specification, implementation and/or deployment</li> </ul> <p>When developing (Create) an API, especially an API specification targeted at the highest level of standardization (see API levels of standardization), it is important to include the viewpoints and insights of all stakeholders. API development is therefore often considered to be a community effort.</p> <p>It is important to mitigate the effects of API changes on API clients. Mitigation includes clear communication when deprecating and retiring an API, but also includes preventing client applications from breaking due to changes to a deployed API.</p> <p>This specification includes requirements for all phases of the API lifecycle and includes requirements for lifecycle management and API versioning.</p>"},{"location":"definitions-and-scope/#api-versioning","title":"API versioning","text":"<p>Updating an API's version is an important measure to help API clients adapt to API changes. Most APIs use the Semantic Versioning (SemVer) scheme and update the API's major version when introducing breaking changes. Non-breaking changes to the API are often reflected by an update in the API's minor version or patch version.</p>"},{"location":"definitions-and-scope/#breaking-changes","title":"Breaking changes","text":"<p>A breaking change to an API is any change that can break a client application. Usually, breaking changes involve modifying or deleting existing parts of an API or adding new required parts. A breaking change can take place in an API specification, API implementation and in an API deployment.</p> <p>Examples of breaking changes are:</p> <ul> <li>Deleting a resource or operation</li> <li>Removing an allowed parameter, request field or response field</li> <li>Modifying a resource or method URI</li> <li>Modifying a field name</li> <li>Adding required query parameters without default values</li> <li>Introducing a new validation</li> <li>Modifying authorization</li> <li>Modifying rate-limiting</li> <li>Removing TLS (Transport Layer Security) versions or supported encryption methods</li> <li>Modifying data formats, encodings, or compression formats</li> </ul> <p>If the intended functionality of an API (method) changes, this might also break the client application and therefore it is considered a breaking change. For example, if a DELETE request previously used to archive a resource but now hard deletes the resource, the change potentially breaks client functionality that is supposed to archive a resource.</p> <p>Breaking changes should be avoided whenever possible.</p>"},{"location":"definitions-and-scope/#non-breaking-changes","title":"Non-breaking changes","text":"<p>Non-breaking changes are changes that cannot be expected to break a client application. Adding optional parts to an API is never considered a breaking change. Examples of non-breaking changes are:</p> <ul> <li>Addition of new endpoints</li> <li>Addition of new resources or operations to existing endpoints</li> <li>Addition of new fields in the following scenarios:<ul> <li>New fields in responses</li> <li>New optional request fields or parameters</li> <li>New required request fields that have default values</li> </ul> </li> <li>Addition of optional query parameters</li> <li>Changes to the order of fields returned within a response</li> <li>Addition of an optional request header</li> <li>Removal of redundant request header</li> <li>Changes to the overall response size</li> <li>Changes to error messages</li> </ul> <p>Requirement LM007 states that API clients MUST be designed to handle non-breaking changes.</p>"},{"location":"definitions-and-scope/#using-a-software-development-kit-sdk-for-easy-access-to-apis","title":"Using a Software Development Kit (SDK) for easy access to APIs","text":"<p>While APIs can be consumed using any platform or programming language, Software Development Kits make it easier to access APIs from a particular platform and/or language of choice. An SDK is usually made up of one or more software libraries, tools, and documentation. For example, Microsoft provides SDKs for accessing Azure APIs from several different platforms, including iOS, Android, JavaScript, and .NET. Another example is the Facebook SDK for integrating Facebook features in games built on the Unity platform.</p> <p>This specification does not require the provision or use of an SDK to access an API. Nevertheless, this specification does include requirements in case an SDK is provided.</p>"},{"location":"definitions-and-scope/#api-protocols-and-api-styles","title":"API protocols and API styles","text":"<p>This document specifies requirements for APIs that are built on top of the HTTP protocol. HTTP, or Hyper Text Transfer Protocol, is the protocol that fuels the World Wide Web. It is a high-level protocol that provides mechanisms for communication between clients and servers with requests and responses. The best-known HTTP client is a web browser that is used to communicate with web servers, requesting data and web pages from web servers or sending user input to web servers.</p> <p>The reason for restricting this specification to HTTP-based APIs is threefold:</p> <ol> <li>The world has been transitioning to the use of HTTP-based APIs ever since the web 2.0 era at the beginning of the   21st century. Therefore most modern API technologies that are based on the HTTP protocol and legacy technologies, such   as CORBA and DCOM, are slowly but surely disappearing from the global arena.</li> <li>As a result of this, many (if not most) standards for secure communication are based on or are working in accordance   with the HTTP protocol. Examples are the numerous RFCs for authorization (like OAuth 2.0) and authentication (like    OpenID Connect), as well as stacks of security protocols such as WS-Security. Other examples include HTTP-header based   content negotiation schemes and protocols for distributed identity management such as the Verifiable Credentials HTTP   API.</li> <li>Modern development tools (as well as developer training materials) are optimized for building applications that   leverage the HTPP protocol and the various design patterns and protocols that work with HTTP or are built on top of   HTTP.</li> </ol> <p>APIs that use the HTTP protocol are often referred to as WEB APIs. WEB APIs are used to communicate between applications over the internet but can also be used for communication over private networks or even between applications on the same machine. WEB APIs are often divided into two groups: SOAP-based APIs and RESTful APIs. SOAP is a protocol on top of HTTP (amongst others) while REST is an architectural style that leverages plain HTTP commands (verbs) for communication between the API client and the API server. SOAP is often associated with the WEB 1.0 era while today's modern WEB APIs are edging towards the REST architectural style. Nevertheless, both SOAP-based APIs and RESTful APIs coexist and many existing and successful initiatives for health information exchange are based on SOAP APIs. Newer WEB API technologies and styles, like GraphQL and gRPC, are rising constantly.</p> <p>This specification strives to provide requirements that apply to all flavours of WEB APIs. However, its focus will be on REST APIs simply because of its growing popularity in Health IT. For example, the popular HL7 FHIR API specification is based on the REST architectural style.</p>"},{"location":"definitions-and-scope/#a-layered-typology-of-apis","title":"A layered typology of APIs","text":"<p>It is common to differentiate between three categories of APIs: system APIs, process APIs and convenience or experience APIs. The Dutch API strategy uses this differentiation which was originally proposed by MuleSoft. This differentiation is based on design principles like 'separation of concerns' and the need for reusability of specifications and software components such as APIs.</p>"},{"location":"definitions-and-scope/#system-apis","title":"System APIs","text":"<p>System APIs are atomic APIs. They expose 'raw' access to data and functionality from a system of record. They cannot be divided into smaller parts without losing usefulness and meaningfulness: you cannot create a meaningful API that exposes the first half of a medical diagnosis or one that creates an outpatient appointment for a particular date without specifying the time. Often, System APIs are exposed for internal use only (see 'Internal and external API usage'). API specifications for System APIs should not be specific to a particular business purpose or 'use case'. Neither should they be specific to a particular type of user or a particular type of system.</p> <p>In healthcare, system APIs provide access to specific data and functionalities in systems like electronic health records, medical imaging systems, Hospital Information Systems, and many others. Many FHIR resources can be used to standardize system APIs. FHIR resource specifications do not define authorization/access control or the authentication of users and clients, which allows them to be used in many different use cases for several types of users.</p>"},{"location":"definitions-and-scope/#process-apis","title":"Process APIs","text":"<p>Process APIs provide a means of combining data and orchestrating multiple system APIs for a specific business purpose. Note that process APIs can combine system APIs from a single backend system but also from a variety of backend systems.</p> <p>In healthcare, the difference between system APIs and process APIs becomes clear when you consider that many healthcare business processes require the combining of data and/or functionality from different systems. For example, transferring a patient from a hospital to a homecare provider often requires combining data from different systems, such as an EHR (Electronic Health Record) system and a PACS system amongst others. A process API that supports the transfer process (for example based on the Dutch eOverdracht specification) uses the system APIs of these 'systems of record' to expose a single coherent dataset to the API client.</p> <p>The latter being a system deployed by (or on behalf of) the homecare provider. Process API specifications for healthcare often define specific methods for authenticating clients/users and define specific authorization/access control methods.</p>"},{"location":"definitions-and-scope/#convenience-or-experience-apis","title":"Convenience or experience APIs","text":"<p>The third category of APIs, convenience APIs or experience APIs, are tailored to a specific kind of usage. For example, an experience API could be tailored to mobile devices and provide mobile-friendly ways of formatting and paginating data. Experience APIs use System APIs or process APIs but format the output in such a way that it caters to the needs of a specific (type of) API client.</p> <p>In healthcare, experience APIs are often representations of business data and/or functionality to a specific Healthcare Information Exchange (HIE) standard, such as a FHIR, or IHE XDS. For example, the previous 'eOverdracht' transfer example could be expressed using two experience APIs: one based on FHIR notifications and compositions and the other on IHE DSUB notifications and XDS document exchange.</p> <p>This specification covers all types of APIs and sets out requirements for reusing APIs of a lower layer.</p>"},{"location":"definitions-and-scope/#consequences-for-api-design-and-specification","title":"Consequences for API design and specification","text":"<p>The layered approach to APIs has consequences for API design and specification in healthcare. Specifications of APIs that support transferring patients (process APIs), should reuse systemlevel API specifications that provide access to specific data. API standards for transferring patients should reuse pre-existing API standards for accessing atomic data, such as atomic FHIR resources.</p> <p>API specifications for a specific (type of) client system, such as a FHIR client, should be harmonized with existing specifications for process APIs.</p>"},{"location":"definitions-and-scope/#exchange-patterns","title":"Exchange patterns","text":"<p>APIs can be used to PUSH data from a client to a server or to PULL data from a server by a client. PUSH and PULL are examples of 'exchange patterns'. Other examples are the NOTIFY-PULL pattern (server notifies the client using an API exposed by the client after which the client pulls data from the server using an API exposed by the server) and the BROADCAST pattern (server broadcasts data to all clients that are interested in receiving that data).</p> <p>This specification strives to provide requirements that are applicable to all possible exchange patterns.</p>"},{"location":"definitions-and-scope/#exchange-paradigms","title":"Exchange paradigms","text":"<p>It is common to differentiate between four different paradigms for exchanging data between systems: operations, messaging, exchanging documents and exposing resources.</p>"},{"location":"definitions-and-scope/#operations","title":"Operations","text":"<p>The operations paradigm, or Remote Procedure Call (RPC) paradigm, allows a client to execute some code on a server by passing it the operation name and required (and optional) arguments. After processing the code, the server returns some content to the client. The content can be anything, from a stream of data to a static document (see document paradigm) or a single scalar value. The SOAP protocol is designed around the operations paradigm.</p>"},{"location":"definitions-and-scope/#messaging","title":"Messaging","text":"<p>Messaging is associated with the 'PUSH' exchange pattern and facilitates automated transactions between systems. System A sends a message to System B with a specific intention and just enough information to justify that intention. Interaction typically occurs without human interaction: a message invokes a state change (such as a workflow state change or changing specific data) within a target system. Typical examples in healthcare are HL7v2 messages and FHIR messages.</p>"},{"location":"definitions-and-scope/#document-exchange","title":"Document exchange","text":"<p>Document exchange is of value in healthcare IT. A document is created by an author and represents a snapshot of available information at a specific time and place: documents are 'stable'. A document can be (digitally) signed by a human, stating that the document is approved by its 'verifier'. A document is first and foremost intended for human consumption (even if it's exchanged by electronic means), but it can be processed by automated systems and automated decisions can be based on its contents, especially if the document has a standardized and machine-readable (structured) format. Note that the document paradigm can be combined with the operation, messaging and resource paradigms, because documents can be the result of an operation, can be transmitted through a message and can be requested from a 'documents' resource.</p> <p>In (Dutch) healthcare, documents have significant value in exchanging data between healthcare organizations. A document can be used to send data between healthcare organizations in accordance with the Dutch WGBO regulation: a healthcare professional transmits specific data (the document) to a specific healthcare provider with a specific purpose (e.g., a transfer or consultation) in accordance with healthcare quality standards or best practices. In such cases data can be transmitted without the specific consent of the patient.</p>"},{"location":"definitions-and-scope/#resources","title":"Resources","text":"<p>As opposed to documents, resources are dynamic. A resource exposes data in response to a specific request and its content changes over time and is dependent on the specifics of the request. Resources are often associated with the PULL and NOTIFY PULL exchange patterns, because a dynamic resource can't be PUSHED to another system. In healthcare, FHIR resources are the most popular example of the resource paradigm. Because of their dynamic nature, exchange of resources across organizations often requires specific consent of the patients concerned.</p> <p>This specification covers all four paradigms and sets out requirements for when to use which paradigm.</p>"},{"location":"definitions-and-scope/#consequences-for-api-design-and-specification_1","title":"Consequences for API design and specification","text":"<p>Different paradigms are suitable for different scenarios. API design and specification should consider that APIs designed using the resource paradigm make the API client responsible for defining the content of the data exposed by the API. The resource paradigm is very flexible from the perspective of the consumer (the API client) but consequently, the healthcare organization responsible for the data has less control over what data is exchanged in what situation.</p>"},{"location":"definitions-and-scope/#internal-and-external-api-usage","title":"Internal and external API usage","text":"<p>Many policies, like the Dutch API strategy and the NHS Open API Architecture Policy, distinguish between internal and external APIs. Indeed, European and Dutch regulations do impose such a distinction but distinguishing internal from external APIs might not always be easy and has nothing to do with technology.</p> <p>Processing personal data is always subject to privacy regulations such as the European GDPR (General Data Protection Regulation). When data is exchanged between organizations, special rules apply. These rules depend on the relationship between those organizations, like the relationship between a (GDPR) 'data controller' and 'data processor'. 'Internal' and 'External' are not a property of the APIs themselves but indicate different use of (sometimes the same) APIs. Although different intended uses may affect API design, our approach is to treat internal or external API design alike as much as possible.</p> <p>In this specification 'internal API usage' is restricted to data exchange within a single data controller. 'External API usage' on the other hand, covers the exchange of data (using APIs) between data controllers (and their respective data processors). External API usage is subject to special regulations such as the Dutch Wabvz and the Dutch NEN 7512 standard.</p> <p>This specification covers both internal and external APIs.</p>"},{"location":"definitions-and-scope/#unrestricted-and-restricted-api-usage","title":"Unrestricted and restricted API usage","text":"<p>APIs can be used to provide unrestricted access to data and functionality. These kinds of APIs don't require authorization to access API functionality and/or data and hence don't need to know the identity of the person or organization using the API. APIs that provide unrestricted use are sometimes referred to as 'Anonymous APIs' or as 'Open Data APIs'.</p> <p>Especially in healthcare, most APIs expose (sensitive) personal data and hence do require authorization. These APIs restrict access to data and/or functionality to specific applications, organizations and/or users. Hence, they need to identify and authenticate API users. This is called 'restricted usage'. APIs that provide 'restricted usage' are sometimes referred to as 'identified APIs'.</p> <p>In real life, even APIs that provide unrestricted use to end-users during operation, do have some restrictions in place that apply to developers. For many APIs special onboarding procedures are in place. Only after onboarding are developers provided with a so-called API key that gives them (their software) access to the API. This allows the organization that provides the API to prevent (deliberate or undeliberate) misuse. It also allows for better statistical analysis of API use.</p> <p>This specification covers both the restricted and unrestricted usage of APIs.</p>"},{"location":"definitions-and-scope/#roles-involved-with-the-development-exploitation-and-use-of-apis","title":"Roles involved with the development, exploitation and use of APIs","text":"<p>APIs are created by developers and are consumed by software created by (other) developers. Sometimes the party responsible for creating and maintaining an API is also responsible for deploying the API. At other times, the development and deployment roles are fulfilled by different parties. The same is true for API clients. Sometimes systems that consume an API, so-called API clients, are developed and deployed by one party, sometimes different parties are responsible for developing and deploying an API client system.</p> <p>Most of the time, the party responsible for developing an API is also responsible for specifying the API. In the case of standard APIs, such as the Dutch MedMij APIs, specifications for APIs are the responsibility of a (National) standards body or 'API specifier', in this case Nictiz. Sometimes, the API specifier is also responsible for verifying API conformance to the specification, sometimes designated 'API conformance verifiers' (such as notified bodies) fulfil such a role.</p> <p>Because separate roles have different responsibilities throughout the lifecycle of an API, most API requirements are specific to a role. This specification recognizes nine roles involved with the creation, deployment and use of APIs. The following diagram sets out these nine roles.</p> <p></p> <p>Each role is briefly introduced in the following table. Requirements in this specification are assigned to one or more roles through the 'applicable roles' attribute of each requirement.</p> API role Responsibilities API client deployer Technical responsibilities for employing an API, as deployed by the API server deployer, and specified by the API specifier, thus implementing the final responsibilities of the API user API client developer Technical responsibilities for supplying software for the API client deployer API infrastructure Technical responsibilities for conveying specified APIs between API clients and API servers API logical designer Responsibilities for logically specifying both data and the operations to be implemented in the API API provider End responsibilities for providing the value and meaning of an API, as agreed with API users API server deployer Technical responsibilities for deploying an API, as specified by an API specifier, thus implementing the end responsibilities of the API provider API server developer Technical responsibilities for supplying software for the API server deployer API specifier Responsibilities for technically specifying the API so that an API server deployer knows what to deploy and an API client knows what to employ API user End responsibilities for using the value and meaning of an API, as agreed with the API provider"},{"location":"definitions-and-scope/#the-contents-of-an-api-specification","title":"The contents of an API specification","text":"<p>An API specification MUST contain enough information for a competent developer to create an API implementation or an API client without further information. This includes:</p> <ol> <li>Identification and authentication of people, organizations, and machines   This does not only apply to the technical standards and specifics used to authenticate entities but also to the   identifying attributes that are used and how to obtain and secure them to create a network of trust.</li> <li>Authorization/access control   This does not only apply to the technical standards and specifics used to authorize access to APIs, but also to the   semantics of access tokens and requests for access tokens, such as the permitted values for permissions   (OAuth 2 scopes) and expiration requirements.</li> <li>Protecting integrity and confidentiality   This applies to any specifics on protecting integrity and confidentiality at both transport and message levels,   including specifics on the cryptographic algorithms, key distribution and PKIs used.</li> <li>Addressing   This applies to specifics on addressing API endpoints and mechanisms used to distribute (updates to) addresses.</li> <li>Content encoding   This applies to specifics on content encoding such as the compression algorithms used and character encoding.</li> <li>Content formatting   Specifics on content formatting such as the use of MTOM/XOP and BSON but also healthcare-specific (data) formats.</li> <li>Exchange patterns and exchange paradigms used</li> <li>API signature and semantics   All actions (methods) that are available through the API MUST be covered, as well as the legitimate data structures   return (error) codes (the API signature), Including a full specification of all API requests and responses.</li> <li>Use cases   How to (and how not to) use the API in specific use cases.</li> <li>References to other specifications   Most specifications reuse other specifications such as RFCs created by IETF or   W3C or Dutch information standards created by Nictiz.</li> </ol> <p>Creating and maintaining the API specification is the responsibility of the API specifier role.</p>"},{"location":"definitions-and-scope/#the-contents-of-api-documentation","title":"The contents of API documentation","text":"<p>API documentation includes, but is not limited to, the API specification. Other important parts of API documentation include:</p> <ul> <li>How to obtain and use test tooling</li> <li>API onboarding and access policies</li> <li>Usage restrictions and guidelines</li> <li>Service level agreements</li> <li>Technical specifics for a particular deployment, such as the use of private networks instead of public internet</li> <li>Addresses of API endpoints</li> </ul> <p>These parts of API documentation are the responsibility of the API server deployer. In many cases, the API server deployer works together with the API server developer or refers to documentation the API server developer supplies.</p>"},{"location":"definitions-and-scope/#api-levels-of-standardization","title":"API levels of standardization","text":"<p>Almost all APIs are based on standards such as communication standards (like the HTTP standard) and formatting standards such as XML. Nevertheless, many APIs use different communication technologies, different documentation formats and testing tools, different methods for discoverability, different data formats, unique styles and patterns and different 'content', for what seems to be similar functionality and purpose. These differences complicate the use of APIs.</p> <p>This specification provides requirements for APIs with various levels of standardization. Even at the lowest level of standardization, the 'Open API level', requirements are set out that harmonize API design, development, deployment, and usage. At the middle level, the 'Technically standardized level', requirements aim at achieving technical harmonization while at the highest level, the 'Fully standardized level', requirements aim at achieving software interoperability.</p> <p>Requirements in this specification are assigned to one or more levels of standardization through the 'applicable levels' attribute of each requirement. Valid values for this attribute are 'OA' (Open API), 'TSA' (Technically Standardized) and 'FSA' (Fully Standardized).</p>"},{"location":"definitions-and-scope/#open-api-standardization-level","title":"'Open API' standardization level","text":"<p>The NHS Open API Architecture Policy uses the following definition of 'Open APIs':</p> <p>'Open APIs are those APIs that have been exposed to enable other systems to interact with that system, and those APIs have been sufficiently documented so that the available functionality is discoverable, fit for purpose and re-usable.'</p> <p>This specification embraces the NHS definition of 'Open APIs'. It is important to disambiguate from the OpenAPI Initiative (formerly Swagger) that standardizes how APIs are described.</p> <p>At the 'Open API' level, the only technical requirements are that:</p> <ul> <li>APIs are based on the HTTP communication protocol (see API protocols and styles)</li> <li>APIs use common and state-of-the-art technologies and standards</li> <li>APIs comply to common security and privacy guidelines and regulations</li> </ul> <p>Other than that, API developers are free to use the technology of their choice and are free to create APIs using their own data formats and 'content'. Even the purpose of these 'Open APIs' is defined by the organization creating them.</p> <p>Requirements at this level aim to increase reusability, discoverability and quality, without restricting APIs to specific technical and/or semantical standards. This preserves agility and increases the speed at which APIs become available to API users and innovators, while at the same time providing some level of harmonization and transparency. Typical requirements at this level concern (transparency of) documentation, testability and onboarding procedures.</p>"},{"location":"definitions-and-scope/#technically-standardized-api-standardization-level","title":"'Technically standardized API' standardization level","text":"<p>Requirements at this level aim to increase the technical harmonization of APIs. Examples of requirements at this level are design rules, requirements for versioning and lifecycle management, security requirements, formatting requirements and transport requirements.</p> <p>Many of these requirements reflect a technical choice, such as using JSON, BSON or XML. Other examples include the compression methods that are allowed (such as GZIP and DEFLATE or the less common LZ4), what security models and standards are allowed (such as OAuth 2 and WS-Security) and what cryptographic methods are allowed for assuring confidentiality and integrity.</p> <p>In Dutch Healthcare, no single party has the authority to enforce these kinds of choices and many technical choices and standards coexist. This specification aims to harmonize technical choices by referring to specific (inter)nationally recognized standards, guidelines and best practices. Sources for these references may include, but are not limited to:</p> <ul> <li>W3C standards</li> <li>Internet Engineering TaskForce (IETF) RFCs</li> <li>OASIS standards</li> <li>International health-IT standardization efforts and standards such as HL7 and IHE</li> <li>The Dutch National Cyber Security Centre (NCSC) security guidelines</li> <li>Dutch NEN norms</li> <li>Dutch 'afsprakenstelsels' such as MedMij</li> <li>Technical agreements between health-IT industry partners such as made by the Dutch Taskforce Samen Vooruit (TSV, now part of NLDigital) and the NUTS foundation</li> </ul> <p>For an API to comply with the requirements at this level it MUST also comply with the requirements at the 'Open API' standardization level.</p>"},{"location":"definitions-and-scope/#fully-standardized-api-standardization-level","title":"'Fully standardized API' standardization level","text":"<p>Requirements at this level aim to increase software interoperability by setting requirements for standardizing all parts of APIs.</p> <p>In Dutch Healthcare, no single party is designated to approve API standards. However, many national and international organizations are concerned with developing API specifications and testing their implementations. Examples of such organizations include, but are not limited to, the Royal Netherlands Standardization Institute 'NEN', the Dutch MedMij foundation, the international HL7, IHE and openEHR foundations and the Dutch NUTS community.</p> <p>An API is fully standardized when:</p> <ul> <li>Its complete specification is approved as a standard by a standardization organization</li> <li>Its implementation is verified by that organization during a formal test or qualification process</li> </ul> <p>Because different standardization organizations can create different standards for the same purpose and use case, 'fully standardized' does not equal 'the only allowed way of doing things'. However, all members of the standardization organization approve the API specification and promote its implementation in real life systems. The Dutch API library for healthcare will include 'competing' fully standardized APIs from different standardization organizations, as long as:</p> <ul> <li>They fulfil the requirements for fully standardized APIs</li> <li>Their organizations are supported by a substantial number of Health IT stakeholders, such as Health IT vendors and/or   healthcare providers</li> <li>Their organizations provide a formal test- or qualification process for API implementations, such as the IHE   connectathon and the Nictiz MedMij qualification tests</li> </ul> <p>In exceptional cases, the Dutch government can force the use of specific standards, such as API standards. The upcoming Wegiz legislation provides the Dutch government with the means to force the use of specific standards for information exchange, including the use of specific fully standardized APIs. Other means to promote the use of specific fully standardized APIs above others are enforcing their use through common purchasing conditions.</p> <p>For an API to comply with the requirements at this level it MUST also comply with the requirements at the 'Open API' and 'Technically standardized' standardization levels.</p>"},{"location":"definitions-and-scope/#api-requirement-categories","title":"API requirement categories","text":"<p>All requirements in this specification fall under a specific category. This specification recognizes nine requirement categories:</p> <ul> <li>API specification &amp; documentation</li> <li>API security</li> <li>API lifecycle management &amp; versioning</li> <li>API Design Rules</li> <li>API testability</li> <li>API onboarding</li> <li>API agreements</li> <li>API discoverability</li> <li>Health Information Standards compliance</li> </ul> <p>Some categories contain requirements on a particular level of standardization (such as the 'Open API standardization level'), others contain requirements on two or even all standardization levels.</p> <p></p> <p>Levels of standardization and requirement categories. Blue cells indicate the availability of requirements for a particular level and category combination.</p>"},{"location":"health-information-standards-compliance/","title":"Health Information Standards compliance","text":""},{"location":"health-information-standards-compliance/#is001-in-order-to-be-fully-standardized-an-api-specification-must-be-approved-by-an-authoritative-body","title":"IS001: In order to be fully standardized, an API specification MUST be approved by an authoritative body","text":"Applicable roles API specifier Standardization levels FSA Status Final Since version 1.0.0"},{"location":"health-information-standards-compliance/#is002-in-order-to-be-fully-standardized-an-api-implementation-must-be-approved-by-an-authoritative-body-during-a-formal-testing-and-qualification-process","title":"IS002: In order to be fully standardized, an API implementation MUST be approved by an authoritative body during a formal testing and qualification process","text":"<p>An API implementation is fully standardized when it is approved by a national standardization organization, or by the national branch of an international standardization organization. Approval is given only as the result of a formal test or qualification process. Proof must be provided for any compliance claim made by the API server developer.</p> Applicable roles API server developer Standardization levels FSA Status Final Since version 1.0.0"},{"location":"health-information-standards-compliance/#is003-all-api-input-and-output-data-should-comply-with-zib-specifications","title":"IS003: All API input and output data SHOULD comply with ZIB specifications","text":"<p>If no ZIB specification is available that governs the contents of certain API input or output but the input or output data represents general health and care concept, the API specifier MAY submit a ZIB change request to the Nictiz ZIB centre.</p> Applicable roles API specifier Standardization levels FSA Status Final Since version 1.0.0"},{"location":"health-information-standards-compliance/#sub-requirements","title":"Sub-requirements","text":"<ul> <li>IS003.001: API input data, such as parameters and post data, SHOULD comply with ZIB specifications where   applicable<ul> <li>Applicable refers to input or output data that represents general health and care concepts.</li> </ul> </li> <li>IS003.002: API output data, such as resources, documents or procedure results SHOULD comply with ZIB   specifications where applicable</li> </ul>"},{"location":"introduction/","title":"Introduction","text":"<p>This specification sets out requirements for Application Programming Interfaces (APIs) in Dutch Healthcare. The importance of complying with a common set of requirements and hence the value of this specification is to:</p> <ul> <li>Promote transparency by setting clear requirements for documentation, testability, discoverability and API onboarding   procedures and agreements</li> <li>Harmonise API requirements and design between different (national) programs for Health Information Exchange and   patient access to health information</li> <li>Guarantee a certain level of quality for all APIs included in the Dutch API library for healthcare</li> <li>Promote innovation through the availability of system data and by exposing application functionality</li> </ul> <p>APIs that conform to the requirements in this specification are permitted for inclusion in the Dutch API library for healthcare. APIs that are included in the Dutch API library for healthcare are more discoverable and are likely to meet the requirements in this specification. Therefore, they meet a certain level of quality.</p> <p>This specification has been developed as part of the Nictiz API strategy.</p>"},{"location":"introduction/#intended-audience","title":"Intended audience","text":"<p>The intended audience for this specification is:</p> <ul> <li>Technical users and developers</li> <li>Policy makers</li> </ul>"},{"location":"notational-conventions/","title":"Notational Conventions","text":"<p>The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119.</p>"},{"location":"notational-conventions/#abbreviations-used-in-this-specification","title":"Abbreviations used in this specification","text":"<p>The following abbreviations are used in this specification:</p> Abbreviation Description API Application Programming Interface: used to allow two or more applications to 'talk to each other' BSON Binary JSON: an optimized version of JSON CDA Clinical Document Architecture: an HL7 standard CORBA Common Object Request Broker Architecture: a standard defined by the Object Management Group (OMG) that enables software components to communicate over a network DCOM Distributed Component Object Model: a Microsoft technology that allows Microsoft 'COM components' to communicate over a network DEFLATE A standard for data compression EHR Electronic Health Record FHIR Fast Healthcare Interoperability Resources: an HL7 standard FSA 'Fully standardized API' level of standardization GDPR General Data Protection Regulation: European privacy law GraphQL A query language for APIs gRPC A remote procedure call framework that leverages the HTTP/2 protocol GZIP A standard for data compression HIE Health Information Exchange HTTP Hyper Text Transfer Protocol: the protocol that fuels the internet IETF Internet Engineering Taskforce: the organization that creates standards for the internet IHE Integrating the Healthcare Enterprise: a worldwide organization for improving system interoperability in healthcare JSON JavaScript Serialized Object Notation: a standard for formatting data LZ4 A standard for data compression MedMij Dutch standard for exchanging health data between Personal Health Record systems and healthcare provider systems NEN Royal Netherlands Standardization Institute NHS National Health Service: government funded national health services in the UK NUTS A Dutch foundation that develops technical standards for Health Information Exchange OA 'Open API' level of standardization OASIS Organization for the Advancement of Structured Information Standards: an international consortium that promotes the adoption of open standards in computing OAuth A standard/framework for authorization OIDC OpenID Connect: a standard for authentication PACS Picture Archiving and Communication System RFC Request For Comments: a purely technical document published by the Internet Engineering Taskforce (IETF) or other standardization organizations. An RFC can be informational, or it can be a standard SDK Software Development Kit SemVer Semantic Versioning: a specification for versioning SOAP Simple Object Access Protocol: a remote procedure call framework on top of HTTP TLS Transport Layer Security: a standard used to secure electronic communications TSA 'Technically standardized API' level of standardization TSV Taskforce Samen Vooruit: a collaboration of vendors that develops and promotes Health Information Exchange standards for Dutch healthcare URI Uniform Resource Identifier: a unique sequence of characters that identifies a logical or physical resource used by web technologies Wabvpz Wet Aanvullende Bepalingen Verwerking Persoonsgegevens in de Zorg: a Dutch law that contains additional privacy regulations for the electronic exchange of healthcare data WGBO Wet op de Geneeskundige Behandel Overeenkomst: a Dutch law that regulates the relationship between patients and care providers WS-Security A set of standards for web service security XDS Cross Enterprise Document Exchange: an IHE integration profile ZIB Zorg Informatie Bouwsteen: the Dutch version of Health and Care Information Models (HCIM)"},{"location":"notational-conventions/#requirement-identification","title":"Requirement identification","text":"<p>Requirements have unique and permanent numbers. In the event of requirements being deprecated or restructured, they are removed from the list. Therefore, gaps in the sequence can occur. New requirements will always get a new and higher number. When the new requirement supersedes an existing requirement, this will be referenced in the new requirement by adding a header \"Supersedes:\".</p>"},{"location":"notational-conventions/#requirement-status","title":"Requirement status","text":"<p>Requirement status is described using the key words \"Draft\", \"Final\", \"Superseded\" and \"Deprecated\". These key words are to be interpreted as follows:</p> <ul> <li>Draft: The requirement is a suggestion and is yet to be approved by key stakeholders.</li> <li>Final: The requirement is approved by key stakeholders and is to be used for conformity assessment.</li> <li>Superseded: The requirement has a known better alternative, but the requirement itself is not going away.</li> <li>Deprecated: The requirement is no longer to be used for conformity assessment.</li> </ul>"},{"location":"notational-conventions/#rules-for-writing-requirements","title":"Rules for writing requirements","text":"<p>To ensure consistent and clear naming, requirements and the accompanying explanations are to be written as follows:</p> <ul> <li>The requirement text MUST be capitalized</li> <li>The requirement text MUST NOT end with a period</li> <li>The explanation text MUST be capitalized</li> <li>The explanation text MUST end with a period</li> <li>When a requirement is conditional, it MUST be of the form \"If [condition], [requirement]\" or \"When [condition],   [requirement]\"</li> <li>A sub-requirement MUST NOT apply to other roles or standardization levels than the main requirement it belongs to</li> </ul> <p>Furthermore:</p> <ul> <li>When terms, abbreviations or acronyms are used, they MUST be written (e.g., capitalized, spaced, hyphenated)   correctly (e.g., OAuth, OpenID Connect, WS-Security, JSON, JWS, NEN 7513, IETF, RFC 7523, W3C, etc.)</li> <li>American (US) English spelling MUST be used (e.g., \"standardization\" instead of \"standardisation\")</li> <li>Straight quotation marks ( ' or \" ) MUST be used instead of curly quotation marks (also known as \"smart quotes\" or   typographer's quotes)</li> </ul>"},{"location":"notational-conventions/#versioning-of-this-specification","title":"Versioning of this specification","text":"<p>This specification follows the Semantic Version 2.0.0 (SemVer) specification for versioning. This means that:</p> <ul> <li>This specification has a version consisting of three parts: MAJOR.MINOR.PATCH</li> <li>The MAJOR number is at least incremented each time requirements are added or changed in such a way that API   specifications, API implementations or API deployments that complied with the previous MAJOR version of this   specification, don't comply with the latest version</li> <li>The MINOR number is at least incremented each time requirements are added or changed in such a way that API   specifications, API implementations and API deployments that complied with the previous MINOR version of this   specification, still comply with the new version</li> <li>The PATCH number is incremented each time textual changes occur that have no influence on the actual meaning of the   requirements in this specification</li> </ul>"}]}